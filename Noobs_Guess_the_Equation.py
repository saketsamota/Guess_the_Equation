import random
def splice(n):
	'''This funtion calculates the result of a simple equation given as a string. It does so by slicing the string where the operator is and calculating the result of the resulting two strings using recursion.''' 
	p = 0
	t = 0
	#first checking if the string has any operator or not.
	for i in n:
		if i.isdigit() == False:
			p +=1
	#if the string has no oprtaor, then the functions just the an integer by directly changing the type of string.
	if p == 0:
		return int(n)
	
	q = 0
	a = ""
	b = ""
	e = ""
	c = 0
	minus = 0
	divi = 0
	#the following loops slices the string at the operators. The order at which the loops are put corresponds to the order of applications of operators.
	for i in range(len(n)):
		if n[i] == "+":
			e = n[i]
			a = n[:i]
			b = n[i+1:]
			q = 1
			break
	#if the string has already been sliced at "+" sign, then the following loop doesn't work and same with all other for loops that follow
	if q != 1:
		for i in range(len(n)):
			if n[i] == "-":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				c = int(n[i+1])
				q = 1
				break
		#this loop is added because of how negative sign works, will see it's use ahead
		for i in range(len(n)):
			if n[i] == "-":
				minus += 1

	if q != 1:
		for i in range(len(n)):	
			if n[i] == "*":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				q = 1
				break

	if q != 1:
		for i in range(len(n)):	
			if n[i] == "/":
				e = n[i]
				a = n[:i]
				b = n[i+1:]
				c = int(n[i+1])
				q = 1
				break
		#same as with negative sign, this loop is added due to different behaviour of division sign, it's use will be seen ahead
		for i in range(len(n)):
			if n[i] == "/":
				divi += 1
	
	#recursion is used to get result of sliced strings as integers
	r = splice(a)
	s = splice(b)
	#the following loops performs the operations on the recursed versions of sliced strings
	if e == "+":
		t = r + s
	#negative has two cases (when there only one minus sign and when there's more than one) because of it's behaviour
	if e == "-" and minus == 1:
		t = r - s
	if e == "-" and minus > 1:
		t = r + s - (2*c)
	if e == "*":
		t = r * s
	#division has two cases (when there only one divide sign and when there's more than one) because of it's behaviour
	if e == "/" and divi == 1:
		t = r / s
	if e == "/" and divi > 1:
		t = (r*s) / (c*c)

	return t

def eqgen():
	'''This funtion is to generate a random which fits the requirements to be an answer for our game. It is generate a different answer every time the game is played'''
	#the equations generated are divided into 3 cases depending on number of digits of the result
	#first case where the answer is 2 digits long
	#this case has 4 more case
	
	#this loop makes random expressions until their answer is a 2-digit integer 
	t = '1001/10'
	while 10 > splice(t) or splice(t) > 100 or type(splice(t)) == float:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		d = random.randint(1,9)
		operators = ['+', '-','*','/']
		#the following are 5 cases where each case is generated by filling 5 places with random integers(1-digit) and operators
		p = ("{}{}{}{}{}".format(a, random.choice(operators),b,random.choice(operators),c))
		q = ("{}{}{}{}{}".format(a,b, random.choice(operators),c,d))
		r = ("{}{}{}{}{}".format(a,b,c, random.choice(operators),d))
		s = ("{}{}{}{}{}".format(a,random.choice(operators),b,c,d))
		#then we put the 5 expressions in list and randomly pick one of them
		l =[p,q,r,s]
		t = random.choice(l)
	
	#this loop makes random expressions until their answer is a 3-digit integer
	u = '10'
	while splice(u) < 99:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		#filling 4 places with 3 random integers and "*" or "+" sign because only multiplication and addition can give us 3-digit numbers 
		p = ("{}*{}{}".format(a,b,c))
		q = ("{}{}*{}".format(a,b,c))
		r = ("{}{}+{}".format(a,b,c))
		s = ("{}+{}{}".format(a,b,c))
		#putting generated expressions in a list and then randomly choosing one of them
		l =[p,q,r,s]
		u = random.choice(l)
        
	#this loop makes random equations for a 1-digit answer
	v = '10'
	while splice(v) > 9 or splice(v) < 0 or type(splice(v)) == float:
		a = random.randint(1,9)
		b = random.randint(1,9)
		c = random.randint(1,9)
		d = random.randint(1,9)
		e = random.randint(1,9)
		operators = ['+', '-','*','/']
		#filling 6 places with random integers(1-digit) and operators
		p1 = ("{}{}{}{}{}{}".format(a,d, random.choice(operators),b,random.choice(operators),c))
		p2 = ("{}{}{}{}{}{}".format(a, random.choice(operators),b,d,random.choice(operators),c))
		p3 = ("{}{}{}{}{}{}".format(a, random.choice(operators),b,random.choice(operators),c,d))
		p4 = ("{}{}{}/{}{}".format(a,b,c,d,e))
		p5 = ("{}{}{}-{}{}".format(a,b,c,e,d))
		#again putting the generated expressions in a list and choosing one of them
		l = [p1,p2,p3,p4,p5]
		v = random.choice(l)
	
	#then we put the 3 chosen expressions in another list and choose one of them
	x = [t,u,v]
	y = random.choice(x)
	return y

#making our answer eqaution by taking the generated expression and it's result and putting them together
z = eqgen()
#s = ("{}={}".format(z,splice(z)))
s='59-8*7=3'

def check(s):
	'''This function checks an eqautions if it satisfies the conditions for our input/answer'''
	#this function checks if the equation has more than 'equal to'(=) sign
	if s.count("=") != 1:
		return 0
	#this function checks if the eqaution has any alphabets in it
	for i in s:
		if i.isalpha():
			return 0
	#this loop checks if the eqaution if too long or too short
	if len(s) != 8:
		return 0
	
	#this loop checks if the equation is actually correct by first slicing it at the "=" sign and calculating the result of the both sides
	for j in range(len(s)):
		if s[j] == "=":
			prefix = s[:j]
			suffix = s[j+1:]
	if splice(prefix) != splice(suffix):
		return 0
	
	return 1

def get_clue(ans, guess):
	'''This function gives the clue using the guess given and the answer.'''
	#first the answer string is changed into a list to aid us in the process 
	answer = [ans[0], ans[1], ans[2], ans[3], ans[4], ans[5], ans[6], ans[7]]
	
	#then a clue list is created with all spaces being "_" by default
	clue = ["_","_","_","_","_","_","_","_"]

	#first we check if the guess satisfies our conditions or not
	if check(guess) != 1:
		return "Not a valid guess"

	#now, we check for any "G"s that we would need to include in the clue
	for idx in range(len(guess)):
		if guess[idx] == ans[idx]:
			clue[idx] = "G"
			answer[idx] = "@"

	#then, we check for the "?"s we need to include
	for idx in range(len(guess)):
		for jdx in range(len(guess)):
			if guess[idx] == answer[jdx] and clue[idx] != "G":
				clue[idx] = "?"
				answer[jdx] = "@"
				break

	#then we makes the string to be returned
	clues = str(clue[0]) + str(clue[1]) + str(clue[2]) + str(clue[3]) + str(clue[4]) + str(clue[5]) + str(clue[6]) + str(clue[7])
	return clues


#then we run the main part of the code
#first the instructions are displayed

instructions = '''=> Guess the Equation in 6 tries. After each guess, each hint will bring you closer to the answer!
=> The answer is an equation and so should be your guesses.
=> You can use 1 2 3 4 5 6 7 8 9 0 - + * / or =
=> The answer has only one number to the right of "=", not another calculation.
=> Standard Order of Operations applies. For example 3+2*5=13 NOT 25.
=> Commutative answers are not allowed. So, if the answer we are looking for is 20+10=30, then we will NOT accept 20+10=30 as the answer (can be used as a guess though.
=> Guide through the hints:
	A "G" means that the digit/operator is in the solution and in the correct spot.
	A "?" means that the digit/operator is in the solution but in the wrong spot.
	A "_" means that the digit/operator is not in the solution at all.

If you ever give up in middle of the game, enter "i" and press enter seee the answer and exit.
Now, press 'Enter' to start the game and enjoy.'''

print(instructions)

input()
q = 0
w = 0

#the following loop takes the inputs and gives out the clues (while loop is used to make sure that invalid inputs are not counted among guesses
while w < 6:
	k = str(input("Enter your guess \n________ \n" ))
	#first we check if the user wants to give up or not
	if k == "i":
		print("YOU GAVE UP ;-;")
		print("The correct answer was", s)
		q = 1
		break
	#taking the input and checking if it satisfies all the conditions
	if check(k) == 1:
		w += 1
	print(get_clue(s,k)) #printing the clue
	
	#displaying the win message if you win
	if k == s:
		q = 1
		print('''YOU WON!! :)''')
		break

#displaying lost message and the answer if you're not able to win
if q == 0:
	print("You lost :(")
	print("The correct answer was", s)
